<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>ScPoEconometrics</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pierre Villedieu" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <script src="https://use.fontawesome.com/5235085b15.js"></script>
    <link rel="stylesheet" href="..\css\scpo.css" type="text/css" />
    <link rel="stylesheet" href="..\css\scpo-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# ScPoEconometrics
## Session 3
### Pierre Villedieu
### SciencesPo Paris </br> 2020-01-10

---


layout: true

&lt;div class="my-footer"&gt;&lt;img src="../img/logo/ScPo-shield.png" style="height: 60px;"/&gt;&lt;/div&gt; 

---



# Recap from from past Lectures and plan for this session

Plan 

* Introduction to Simple Linear Regression Model

* Study the relation between **class size** and **students performance**

---

# Data

Student performance and class size 

.pull-left[
* Let's first download the data from [here](https://www.dropbox.com/s/2g16pid3eky44bp/grades_classize.RData?dl=0). ADD SOURCE


* What are the variables? What is an observation here? 

* How the average math score (`av_grade`) is related to class size (`classize`)? 

* What is a good summary of their relationship?

]

--

.pull-right[
* Let's plot these two variables together. 

&lt;img src="chapter3_files/figure-html/unnamed-chunk-2-1.svg" style="display: block; margin: auto;" /&gt;
]

---

# A Line throught the Scatterplot

.left-wide[
&lt;img src="chapter3_files/figure-html/unnamed-chunk-3-1.svg" style="display: block; margin: auto;" /&gt;
]

--

.right-thin[
&lt;br&gt;
&lt;br&gt;

* A *line*! Great. But **which** line? This one?

* That's a *flat* line. But `av_grade` is increasing. 

* üò©

]

---

# A Line throught the Scatterplot

.left-wide[
&lt;img src="chapter3_files/figure-html/unnamed-chunk-4-1.svg" style="display: block; margin: auto;" /&gt;
]

--

.right-thin[
&lt;br&gt;
&lt;br&gt;

* **That** one?

* Slightly better. Has a *slope* and an *intercept*.

* üòê

]


---

# Writing Down A *Line*

.pull-left[
* We observe `\((y_i,x_i)\)` in the data.

* This describes a line with intercept `\(b_0\)` and slope `\(b_1\)`:
    $$
    \widehat{y}_i = b\_0 + b\_1 x\_i
    $$

* We call `\(\widehat{y}_i\)` the *prediction* for `\(y_i\)`.

* Most of the times, `\(\widehat{y}_i \neq y_i\)`, i.e. we make an *error*.
]

--

.pull-right[

* At point `\(x_i\)` we make error `\(e_i\)`.

* Our aim will be to keep the error *as small as possible*, while at the same time giving a reasonable description of the data.

* (We could be more generally trying to fit a *curve* rather than a *line*, by the way.)

* The *actual data* `\((y_i,x_i)\)` can thus be written like *prediction + error*:
    $$
    y_i = b_0 + b_1 x_i + e_i
    $$
]



---

# Making Errors





.left-wide[
&lt;img src="chapter3_files/figure-html/line-arrows-1.svg" style="display: block; margin: auto;" /&gt;
]

.right-thin[
* Red Arrows are *errors* or *residuals* for each prediction.

* Often denoted `\(u\)` or `\(e\)`.

* Note that we have both `\(e&gt;0\)` and `\(e&lt;0\)`!
]

---
class: inverse

# App Time!

* Let's try to find the best line using only the *absolute value* of errors!


```r
library(ScPoEconometrics) # load our library
launchApp('reg_simple_arrows')
aboutApp('reg_simple_arrows') # explainer about app
```

---

# Writing Down *The Best* Line

.pull-left[
* choose `\((b_0,b_1)\)` s.t. the sum `\(e_1^2 + \dots + e_N^2\)` is **as small as possible**

* `\(e_1^2 + \dots + e_N^2\)` is the *sum of squared residuals*, or SSR.

* Wait a moment... Why *squared* residuals?!
]

--

.pull-right[

* In previous plot, errors of different sign `\((+/-)\)` cancel out!

* This makes it hard to find a good line.

* Squaring each `\(e_i\)` solves that issue as `\(e_i^2 \geq 0, \forall i\)`.
]


---

# Best Line and Squared Errors

.left-wide[
&lt;img src="chapter3_files/figure-html/line-squares-1.svg" style="display: block; margin: auto;" /&gt;
]

--

.right-thin[
&lt;br&gt;
&lt;br&gt;

* **That's**  the one!

* Perfect! Minimizes the sum of squares.

* üòå

]

---
class: inverse

# App Time!



```r
launchApp('reg_simple')
aboutApp('reg_simple')
```


---

# Ordinary Least Squares (OLS)

.pull-left[
* OLS estimates the best line for us.

* In our single regressor case, there is a simple formula for the slope:
  $$
  b_1 = \frac{cov(x,y)}{var(x)}
  $$
  
* and for the intercept
  $$
  b_0 = \bar{y} - b_1\bar{x}
  $$

* üö® You **must** know and understand those formulae!

]

--

.pull-right[

**Interpretation** (for now we assume x and y to be numerical). 

* Intercept `\((b_0)\)` : The predicted value of `\(y\)` if `\(x\)` is set to 0

* Slope `\((b_1)\)` : The change in `\(y\)` associated to an increase of `\(x\)` by one unit. 

]
  
---

# OLS : class size and average math score

Let's take back our grades-class size example! 

.pull-left[

&lt;img src="chapter3_files/figure-html/unnamed-chunk-9-1.svg" style="display: block; margin: auto;" /&gt;
]

--

.pull-right[

* **OLS in `R`**. You can run an OLS regression by executing this command


```r
reg = lm(av_grade~classsize,grades) # assign the result of the regression to the "reg" object 
summary(reg) # to view the output 
```


* We get theses values for `\(b_0\)` and `\(b_1\)`


```
## (Intercept)   classsize 
##  59.6719860   0.2367362
```

* Interpret these two values.


]

---

class: inverse

# App Time!

How does OLS actually perform the minimization problem?


```r
launchApp('SSR_cone')
aboutApp('SSR_cone')  # after
```


---
class: inverse

# App Time!


Let's do some more OLS!


```r
launchApp('reg_full')
aboutApp('reg_full')  # after
```

---

# OLS without any Regressor

.pull-left[
* Our line is flat at level `\(b_0\)`:
  `$$y = b_0$$`
* Our optimization problem is now
  `$$b_0 = \arg\min_{\text{int}} \sum_{i=1}^N \left[y_i - \text{int}\right]^2,$$`
* With solution
  `$$b_0 = \frac{1}{N} \sum_{i=1}^N y_i = \overline{y}.$$`
]

--

.pull-right[
* In other words: Estimates the **mean** of `\(y\)`!

&lt;img src="chapter3_files/figure-html/unnamed-chunk-14-1.svg" style="display: block; margin: auto;" /&gt;
]


---

# Other OLS Restrictions

* There are other restrictions we can impose.

* They are described [in the book](https://scpoecon.github.io/ScPoEconometrics/linreg.html#OLS). Optional ü§ì.

* There is an app for each of them:
&lt;br&gt;
&lt;br&gt;

type | App  
-------- | --------
No Intercept | `launchApp('reg_constrained')` 
Centered Regression | `launchApp('demeaned_reg')` 
Standardized Regression | `launchApp('reg_standardized')`


---

# Predictions and Residuals


1. The error is `\(e_i = y_i - \widehat{y}_i\)`

2. The average of `\(\widehat{y}_i\)` is equal to `\(\bar{y}\)`.
    `$$\begin{align}\frac{1}{N} \sum_{i=1}^N \widehat{y}_i &amp;= \frac{1}{N} \sum_{i=1}^N b_0 + b_1 x_i \\ &amp;= b_0 + b_1  \bar{x}  = \bar{y} \end{align}$$`
--
3. Then,
    `$$\frac{1}{N} \sum_{i=1}^N e_i = \bar{y} - \frac{1}{N} \sum_{i=1}^N \widehat{y}_i = 0$$`
    i.e. the average of errors is zero.

---


# Properties of Residuals

.pull-left[
1. The average of `\(\widehat{y}_i\)` is the same as the mean of `\(y\)`.

2. The average of the errors should be zero.

3. Prediction and errors should be *uncorrelated* (i.e. orthogonal).

Let's look at the data behind our *arrows* plot above:

]

--

.pull-right[
To be fixed


]

---

# Properties of Residuals

.pull-left[

1. The average of `\(\widehat{y}_i\)` is the same as the mean of `\(y\)`.

2. The average of the errors should be zero.

3. Prediction and errors should be *uncorrelated* (i.e. orthogonal).
]

--

.pull-right[

```r
# 1.
all.equal(mean(sd$y_hat), mean(sd$y))
```

```
## [1] TRUE
```

```r
# 2.
all.equal(mean(sd$error), 0)
```

```
## [1] TRUE
```

```r
# 3.
all.equal(cov(sd$error,sd$y_hat), 0)
```

```
## [1] TRUE
```
]

---


# Linear Statistics

* It's important to keep in mind that Var, Cov, Corr and Regression measure **linear relationships** between two variables.

* Two datasets with *identical* correlations could look *vastly* different.

* They would have the same regression line.

* Same correlation coefficient.

--

* Is that even possible?

---

# Linear Statistics: Anscombe

* Francis Anscombe (1973) comes up with 4 datasets with identical stats. But look!

.left-wide[

&lt;img src="chapter3_files/figure-html/unnamed-chunk-17-1.svg" style="display: block; margin: auto;" /&gt;
]

--

.right-thin[
To be fixed 


]
---

# Dinosaurs in your Data?

* So, be wary of only looking a linear summary stats.
* Also look at plots.
* Dinosaurs?
    
    ```r
    launchApp("datasaurus")
    aboutApp("datasaurus")
    ```

---

# Nonlinear Relationships in Data?

* We can accomodate non-linear relationships in regressions.

* We'd just add a higher order term like this:
    $$
    y_i = b_0 + b_1 x_i + b_2 x_i^2 + e_i
    $$
    
* This is *multiple regression* (next chapter!)

---

# Nonlinear Relationships in Data?

* For example, suppose we had this data and fit the above regression:
    &lt;img src="chapter3_files/figure-html/non-line-cars-ols2-1.svg" style="display: block; margin: auto;" /&gt;

---
# Analysis of Variance

* Remember that `\(y_i = \widehat{y}_i + e_i\)`.

* We have the following decomposition:
    `$$\begin{align} Var(y) &amp;= Var(\widehat{y} + e)\\&amp;= Var(\widehat{y}) + Var(e) + 2 Cov(\widehat{y},e)\\&amp;= Var(\widehat{y}) + Var(e)\end{align}$$`
    
* Because: `\(Cov(\hat{y},e)=0\)`

* Total variation (SST) = Model explained (SSE) + Unexplained (SSR)


---

# Assessing the Goodness of Fit

* The `\(R^2\)` measures how good the model fits the data.

* `\(R^2\)` close to `\(1\)` indicates a very high explanatory power of the model, `\(R^2\)` close to `\(0\)` means that the variations in the outcome `\((y)\)` are very poorly captured.
    $$
    R^2 = \frac{\text{variance explained}}{\text{total variance}} =     \frac{SSE}{SST} = 1 - \frac{SSR}{SST}\in[0,1]
    $$
    
* NB: Small `\(R^2\)` doesn't mean it's a useless model!

---

# An Example - Log Wage Equation


---

# An Example - Log Wage Equation


---

# An Example - Log Wage Equation


---

# An Example - Log Wage Equation


---

# An Example - Log Wage Equation


---

# An Example - Log Wage Equation


---

class: title-slide-final, middle
background-image: url(../img/logo/ScPo-econ.png)
background-size: 250px
background-position: 9% 19%

# END




|                                                                                                            |                                   |
| :--------------------------------------------------------------------------------------------------------- | :-------------------------------- |
| &lt;a href="mailto:pierre.villedieu@sciencespo.fr"&gt;.ScPored[&lt;i class="fa fa-paper-plane fa-fw"&gt;&lt;/i&gt;]               | pierre.villedieu@sciencespo.fr       |
| &lt;a href="https://github.com/ScPoEcon/ScPoEconometrics-Slides"&gt;.ScPored[&lt;i class="fa fa-link fa-fw"&gt;&lt;/i&gt;] | Slides |
| &lt;a href="https://scpoecon.github.io/ScPoEconometrics"&gt;.ScPored[&lt;i class="fa fa-link fa-fw"&gt;&lt;/i&gt;] | Book |
| &lt;a href="http://twitter.com/ScPoEcon"&gt;.ScPored[&lt;i class="fa fa-twitter fa-fw"&gt;&lt;/i&gt;]                          | @ScPoEcon                         |
| &lt;a href="http://github.com/ScPoEcon"&gt;.ScPored[&lt;i class="fa fa-github fa-fw"&gt;&lt;/i&gt;]                          | @ScPoEcon                       |
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../js/ru_xaringan.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
